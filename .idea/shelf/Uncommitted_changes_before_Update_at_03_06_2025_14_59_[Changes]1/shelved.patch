Index: app/get_traffic_volume_endpoint/shemas.py
===================================================================
diff --git a/app/get_traffic_volume_endpoint/shemas.py b/app/get_traffic_volume_endpoint/shemas.py
deleted file mode 100644
--- a/app/get_traffic_volume_endpoint/shemas.py	
+++ /dev/null	
@@ -1,15 +0,0 @@
-from pydantic import BaseModel
-
-
-class TrafficRequest(BaseModel):
-    rain: float
-    snow: float
-    temp: float
-    cloud: float
-    hour: float
-    day: int
-    month: int
-
-
-class TrafficResponse(BaseModel):
-    traffic_volume: float
Index: app/utils/congestion.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/utils/congestion.py b/app/utils/congestion.py
new file mode 100644
--- /dev/null	
+++ b/app/utils/congestion.py	
@@ -0,0 +1,10 @@
+def classify_congestion(speed):
+    if speed > 40:
+        return 1, "#00cc44"  # зеленый
+    elif speed > 25:
+        return 4, "#ffcc00"  # желтый
+    elif speed > 10:
+        return 7, "#ffaa00"  # оранжевый
+    else:
+        return 9, "#cc0000"  # красный
+
Index: app/get_traffic_volume_endpoint/schemas.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/get_traffic_volume_endpoint/schemas.py b/app/get_traffic_volume_endpoint/schemas.py
new file mode 100644
--- /dev/null	
+++ b/app/get_traffic_volume_endpoint/schemas.py	
@@ -0,0 +1,43 @@
+from pydantic import BaseModel, field_validator
+from typing import List
+from datetime import datetime
+
+
+class RouteRequest(BaseModel):
+    coords: List[List[float]]  # [[lat, lon], ]
+    datetime: str
+
+    @field_validator('datetime')
+    def validate_datetime(cls, v):
+        if v is None:
+            raise ValueError("Поле 'datetime' не может быть пустым или отсутствовать")
+        try:
+            dt = datetime.fromisoformat(v.replace('Z', '+00:00'))
+            future_date = datetime(2026, 5, 5, 15, 15)
+            min_date = datetime(2025, 1, 1)
+            if dt < min_date or dt > future_date:
+                raise ValueError(f"Дата должна быть в диапазоне с {min_date.date()} по {future_date.date()}")
+            return v
+        except ValueError as e:
+            raise ValueError("Неверный формат даты. Используйте ISO 8601 (например, '2025-05-01T14:00:00').")
+
+    @field_validator('coords', mode='after')
+    def validate_coords(cls, v):
+        if not isinstance(v, list):
+            raise ValueError(f"Поле 'coords' должно быть списком, получено: {type(v).__name__}")
+        for i, coord in enumerate(v):
+            if not isinstance(coord, list):
+                raise ValueError(f"Элемент {i} в 'coords' должен быть списком, получено: {type(coord).__name__}")
+        for coord in v:
+            if len(coord) != 2:
+                raise ValueError("Каждая координата должна содержать два значения: [долгота, широта]")
+            lon, lat = coord
+            if not (-180 <= lon <= 180):
+                raise ValueError(f"Долгота ({lon}) должна быть в диапазоне [-180, 180]")
+            if not (-90 <= lat <= 90):
+                raise ValueError(f"Широта ({lat}) должна быть в диапазоне [-90, 90]")
+        return v
+
+
+class PredictionResponse(BaseModel):
+    route: List[dict]
Index: app/models/model.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/models/model.py b/app/models/model.py
new file mode 100644
--- /dev/null	
+++ b/app/models/model.py	
@@ -0,0 +1,32 @@
+import torch
+import torch.nn.functional as F
+from torch import nn
+from torch_geometric.nn import GATConv
+
+
+class TrafficGNN(nn.Module):
+    def __init__(self, in_channels, hidden_channels):
+        super().__init__()
+
+        self.gat1 = GATConv(in_channels, hidden_channels, heads=2, concat=True)
+        self.bn1 = nn.BatchNorm1d(hidden_channels * 2)
+        self.dropout1 = nn.Dropout(p=0.3)
+
+        self.gat2 = GATConv(hidden_channels * 2, hidden_channels)
+        self.bn2 = nn.BatchNorm1d(hidden_channels)
+        self.dropout2 = nn.Dropout(p=0.3)
+
+        self.lin = nn.Linear(hidden_channels, 1)
+
+    def forward(self, x, edge_index):
+        x = self.gat1(x, edge_index)
+        x = self.bn1(x)
+        x = F.relu(x)
+        x = self.dropout1(x)
+
+        x = self.gat2(x, edge_index)
+        x = self.bn2(x)
+        x = F.relu(x)
+        x = self.dropout2(x)
+
+        return self.lin(x).squeeze(-1)
\ No newline at end of file
Index: app/utils/gnn_inference.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/utils/gnn_inference.py b/app/utils/gnn_inference.py
new file mode 100644
--- /dev/null	
+++ b/app/utils/gnn_inference.py	
@@ -0,0 +1,28 @@
+import torch
+import numpy as np
+from app.utils.time_features import get_time_features
+
+
+def predict_speed(model, x_map, edge_index, dt):
+    """
+    выполняет инференс по всей дорожной сети и возвращает словарь link_id => скорость (км/ч)
+    """
+    time_feat = get_time_features(dt)
+
+    x_list = []
+    lid_to_idx = {}
+    for i, (lid, road_feat) in enumerate(x_map.items()):
+        full_feat = torch.cat([road_feat, time_feat])  # объединяем road + time признаки
+        x_list.append(full_feat)
+        lid_to_idx[lid] = i
+
+    x_tensor = torch.stack(x_list)
+
+    model.eval()
+    with torch.no_grad():
+        y_pred = model(x_tensor, edge_index) * 120.0  # денормализация
+
+    # возвращаем предсказания: link_id => скорость
+    pred_dict = {lid: float(y_pred[idx]) for lid, idx in lid_to_idx.items()}
+    return pred_dict
+
Index: app/utils/time_features.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/utils/time_features.py b/app/utils/time_features.py
new file mode 100644
--- /dev/null	
+++ b/app/utils/time_features.py	
@@ -0,0 +1,13 @@
+import numpy as np
+import torch
+
+
+def get_time_features(dt):
+    hour = dt.hour + dt.minute / 60.0
+    day_of_week = dt.weekday()
+    hour_sin = np.sin(2 * np.pi * hour / 24)
+    hour_cos = np.cos(2 * np.pi * hour / 24)
+    dow_sin = np.sin(2 * np.pi * day_of_week / 7)
+    dow_cos = np.cos(2 * np.pi * day_of_week / 7)
+    return torch.tensor([hour_sin, hour_cos, dow_sin, dow_cos], dtype=torch.float32)
+
Index: app/utils/geo.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/utils/geo.py b/app/utils/geo.py
new file mode 100644
--- /dev/null	
+++ b/app/utils/geo.py	
@@ -0,0 +1,70 @@
+from typing import List, Tuple
+import pandas as pd
+from scipy.spatial import KDTree
+import numpy as np
+from pyproj import Transformer
+from collections import defaultdict
+
+
+def to_mercator(lon: float, lat: float) -> Tuple[float, float]:
+    transformer = Transformer.from_crs("epsg:4326", "epsg:3857", always_xy=True)
+    return transformer.transform(lon, lat)
+
+
+# находим все link_id находящиеся в пределах max_dist_meters (100м) от маршрута (GPS-точек)
+# используем проекцию меркатора и KDTree в метрах
+def get_nearest_links(
+        coords: List[Tuple[float, float]],
+        tree: KDTree,
+        link_gps_df: pd.DataFrame,
+        max_dist_meters: float = 100.0) -> List[int]:
+    if not coords:
+        return []
+
+    # преобразуем маршрут в метры
+    mercator_coords = [to_mercator(lon, lat) for lon, lat in coords]  # lat/lon в lon/lat
+
+    # дерево точек уже должен быть построен в метрах
+    idx_lists = tree.query_ball_point(mercator_coords, r=max_dist_meters)
+    flat_idxs = [i for sublist in idx_lists for i in sublist]
+    if not flat_idxs:
+        return []
+
+    nearest_links = link_gps_df.iloc[flat_idxs]["link_id"].tolist()
+    return list(set(nearest_links))
+
+
+# строим словарь link_id - соседи (по edge_index)
+def build_link_neighbors(edge_index_tensor, link_ids):
+    neighbors_dict = defaultdict(set)
+    edge_index_np = edge_index_tensor.cpu().numpy()
+    for src_idx, dst_idx in zip(edge_index_np[0], edge_index_np[1]):
+        src_lid = link_ids[src_idx]
+        dst_lid = link_ids[dst_idx]
+        neighbors_dict[src_lid].add(dst_lid)
+        neighbors_dict[dst_lid].add(src_lid)
+    return neighbors_dict
+
+
+#  возвращаем до k соседей link_id из заранее построенного neighbors_dict
+def get_k_neighbours_via_edge_index(link_id: int, neighbors_dict: dict, k: int = 5) -> list:
+    if link_id not in neighbors_dict:
+        return []
+    neighbors = list(neighbors_dict[link_id])
+    return neighbors[:k]
+
+
+# экстраполируем скорость для неизвестного link_id на основе его соседей из neighbors_dict
+def extrapolate_speed(
+        lid: int,
+        pred_dict: dict,
+        neighbors_dict: dict) -> tuple[float, bool]:
+    if lid not in neighbors_dict:
+        return None, False
+    neighbors = neighbors_dict[lid]
+    known_speeds = [pred_dict[n] for n in neighbors if n in pred_dict]
+    if known_speeds:
+        return float(np.mean(known_speeds)), True
+    return None, False
+
+
Index: tests/locust_test.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/tests/locust_test.py b/tests/locust_test.py
new file mode 100644
--- /dev/null	
+++ b/tests/locust_test.py	
@@ -0,0 +1,27 @@
+from locust import HttpUser, task, between
+
+class TrafficPredictionUser(HttpUser):
+    wait_time = between(0.1, 1)
+    @task
+    def predict_traffic(self):
+        self.client.post(
+            "/predict_traffic",
+            json={
+                "coords": [[116.328736, 39.905811], [116.328971, 39.905807], [116.329021, 39.905807],
+                           [116.329121, 39.905808], [116.329299, 39.905905], [116.33029, 39.905892],
+                           [116.331396, 39.905878], [116.3317, 39.905875], [116.333557, 39.905851],
+                           [116.333642, 39.90585], [116.335891, 39.905911], [116.33699, 39.905893],
+                           [116.337301, 39.905884], [116.337527, 39.905883], [116.337663, 39.905879],
+                           [116.339355, 39.905867], [116.339543, 39.905865], [116.339892, 39.905864],
+                           [116.340059, 39.905864], [116.340518, 39.90586], [116.34363, 39.905834],
+                           [116.34425, 39.905833], [116.346227, 39.905807], [116.346417, 39.905804],
+                           [116.349485, 39.905767], [116.349652, 39.905764], [116.349964, 39.905763],
+                           [116.35009, 39.905763], [116.35076, 39.905763], [116.351039, 39.905761],
+                           [116.351214, 39.905762], [116.351462, 39.905759], [116.352664, 39.905757],
+                           [116.352848, 39.905757], [116.353347, 39.905753], [116.354777, 39.905752],
+                           [116.356678, 39.905751]],
+                "datetime": "2025-05-01T16:10"
+            }
+        )
+
+
